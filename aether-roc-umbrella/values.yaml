# SPDX-FileCopyrightText: 2020-present Open Networking Foundation <info@opennetworking.org>
#
# SPDX-License-Identifier: LicenseRef-ONF-Member-1.0

# Default values for all Aether Helm charts.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

global:
  fullnameOverride: "onos"
  nameOverride: ""
  image:
    registry: ""
    tag: ""
  store:
    consensus:
      enabled: true
      name: ""
      image:
        registry: ""
        repository: atomix/atomix-raft-storage-node
        tag: ""
        pullPolicy: IfNotPresent
        pullSecrets: []
      clusters: 1
      replicas: 1
      partitions: 1
      persistence:
        storageClass: ""
        storageSize: 1Gi
  # Deprecated: use 'store' instead
  storage:
    controller: "atomix-controller.kube-system.svc.cluster.local:5679"
    consensus:
      enabled: false
      name: ""
      type: raft
      image: ""
      imagePullPolicy: IfNotPresent
      partitions: 1
      replicas: 1
      partitionsPerCluster: 1
      clusters: 1

import:
  onos-topo:
    enabled: true
  onos-config:
    enabled: true
  onos-gui:
    enabled: true
  onos-cli:
    enabled: true
  aether-roc-api:
    enabled: true
  aether-roc-gui:
    enabled: true
  sdcore-adapter:
    enabled: true
  sdcore-test-dummy:
    enabled: true

# ONOS-TOPO
onos-topo:
  store:
    consensus:
      enabled: false
  # Deprecated: use 'store' instead
  storage:
    consensus:
      enabled: false

# ONOS-GUI
onos-gui: {}

# ONOS-CLI
onos-cli:
  postInstall:
    topo: spgw-1-topo-entities.json
# Use "--set onos-cli.postInstall=null" to disable

# Aether ROC API
aether-roc-api: {}

# Aether ROC GUI
aether-roc-gui: {}

# SD-Core Adapter
sdcore-adapter:
  nameOverride: sdcore-adapter
  fullnameOverride: sdcore-adapter
  prometheusEnabled: false

# SD-Core Test Dummy
# proxy_pass has to be added or nginx will not log the $request_body
sdcore-test-dummy:
  service:
    type: NodePort
  serverBlock: |-
    log_format client '$remote_addr - $remote_user $request_time $upstream_response_time '
                      '[$time_local] "$request" $status $body_bytes_sent $request_body "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    server {
      listen 0.0.0.0:8080;
      default_type application/json;
      access_log /opt/bitnami/nginx/logs/access.log client;

      # You can provide a special subPath or the root
      location = /v1/config {
        root /;
        proxy_pass http://127.0.0.1:8080/post_dummy;
      }
      location = /v1/config/policies {
        root /;
        proxy_pass http://127.0.0.1:8080/post_dummy;
      }
      location = /v1/config/imsis {
        root /;
        proxy_pass http://127.0.0.1:8080/post_dummy;
      }
      location = /post_dummy {
        # turn off logging here to avoid double logging
        access_log off;
        return 200;
      }
      error_page  405     =200 $uri;
    }

# ONOS-CONFIG
onos-config:
  store:
    consensus:
      enabled: false
  # Deprecated: use 'store' instead
  storage:
    controller: ""
    consensus:
      enabled: false
  models:
    aether:
      v1:
        enabled: false
      v2:
        enabled: false
      v2_1:
        enabled: true
      v2_2:
        enabled: false
      v3:
        enabled: true
  openpolicyagent:
    enabled: true
    rego:
      aether_3_0_0.rego: |-
          # SPDX-FileCopyrightText: 2021-present Open Networking Foundation <info@opennetworking.org>
          #
          # SPDX-License-Identifier: LicenseRef-ONF-Member-1.0

          package aether_3_0_0

          allowed[config] {
            ap_list := input.ap_list.ap_list
            application := input.application.application
            connectivity_service := input.connectivity_service.connectivity_service
            device_group := devicegroups # refer to rule below
            enterprise := enterprises # refer to rule below
            ip_domain := input.ip_domain.ip_domain
            network := input.network.network
            site := sites # refer to rule below
            template := input.template.template
            upf := input.upf.upf
            vcs := vcss # refer to rule below
            config := {
              "ap-list": {
                "ap-list": [
                    ap_list
                ]
              },
              "application": {
                "application": [
                    application
                ]
              },
              "connectivity-service": {
                "connectivity-service": [
                    connectivity_service
                ]
              },
              "device-group": {
                "device-group": [
                    device_group
                ]
              },
              "enterprise": {
                "enterprise": [
                    enterprise
                ]
              },
              "ip-domain": {
                "ip-domain": [
                    ip_domain
                ]
              },
              "network": {
                "network": [
                    network
                ]
              },
              "site": {
                "site": [
                    site
                ]
              },
              "template": {
                "template": [
                    template
                ]
              },
              "upf": {
                "upf": [
                    upf
                ]
              },
              "vcs": {
                "vcs": [
                    vcs
                ]
              }
            }
          }

          enterprises[enterprise] {
            enterprise := input.enterprise.enterprise[_]
            enterprise.id == input.groups[i]
          }

          connectivityservices[connectivity_service] {
            enterprise := input.enterprise.enterprise[_]
            enterprise_cs := enterprise.connectivity_service[_]
            connectivity_service := input.connectivity_service.connectivity_service[_]
            enterprise.id == input.groups[i]
            enterprise_cs.connectivity_service == connectivity_service.id
          }

          can_update_enterprise = true {
            update_enterprise := input.updates.enterprise.enterprise[_]
            update_enterprise.id == input.groups[i]
          }
          #
          #can_delete_enterprise = true {
          #    false # Can't delete your own enterprise
          #}
          #
          sites[site] {
            site := input.site.site[_]
            site.enterprise == input.groups[i]
          }

          #can_update_site = true {
          #    update_sites := input.updates.site.site[_]
          #    update_sites.enterprise == input.groups[i]
          #}
          #
          #can_delete_site = true {
          #    delete_site := input.deletes.site.site[_]
          #    site := input.site.site[_]
          #    site.id == delete_site.id
          #    site.enterprise == input.groups[i]
          #}

          devicegroups[device_group] {
            site := input.site.site[_] # the existing set of site(s)
            device_group := input.device_group.device_group[_] # the existing set of device_group(s)
            device_group.site == site.id # allow only the device_groups of a known site
            site.enterprise == input.groups[i] # check a known site is for one of our groups
          }

          #can_update_devicegroups = true {
          #    site := input.site.site[_] # the existing set of sites
          #    update_device_group := input.updates.device_group.device_group[_] # the set of device_group(s) to be updated
          #    update_device_group.site == site.id # check the device group is for a known site
          #    site.enterprise == input.groups[i] # check a known site is for one of our groups
          #}
          #
          #can_delete_devicegroups = true {
          #    site := input.site.site[_] # the existing set of sites
          #    device_group := input.device_group.device_group[_] # the existing set of device_groups
          #    delete_device_group := input.deletes.device_group.device_group[_] # the device group(s) to be deleted
          #    delete_device_group.id == device_group.id # check device_group to be deleted actually exists
          #    site.id == device_group.site # check the device group is for known site
          #    site.enterprise == input.groups[i] # check site is for one of our groups
          #}

          vcss[vcs] {
            vcs := input.vcs.vcs[_]
            site := input.site.site[_]
            devicegroup := input.device_group.device_group[_]
            devicegroup.site == site.id
            vcs.device_group == devicegroup.id
            site.enterprise == input.groups[i]
          }
